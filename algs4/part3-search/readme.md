# 查找

符号表--字典，通过键来取值

符号表：二叉查找树、红黑树和散列表

## 顺序查找(无序链表)

低效

## 二叉查找树

已经足够高效，但是在某些场景下仍旧不够好，

**因为** 在一棵二叉查找树中，所有操作在最坏情况下所需的时间和高度成正比

但是普通的二叉查找树不是平衡的

## 平衡查找树

完全平衡的代价非常高，需要一种灵活的查找树：2-3 查找树(2、3 节点)

但是这种方式需要考虑的边际情况太多，代码实现效率页比较慢

2 节点：一个键 2 条连接，左小又大
3 节点：含有 2 个键 3 条连接，左小，中居于中间，右大

## 红黑二叉查找树

3 节点是红链接：**左斜的红色链接相连的两个节点(两个节点中的一个是左节点)**
2 节点是黑链接，即普通连接定义

1.  红链接均为左链接
2.  没有任何一个节点同时和两条红链接相连
3.  该树是完美黑色平衡的，即任意空链接到跟节点路径上的黑链接数量相同

## 2 节点插入

1.  左插入 作为一个指向新建节点的红链接
2.  右插入 旋转为左红连接

## 向树根底部 2 节点插入新建

1.  如果插入的是右红连接，通过左旋转

结论：所有基于红黑树的符号表实现都能保证操作的运行时间为对数级别，一颗大小为 N 的红黑树，高度不会超过 2logN，根结点到任意节点的平均路径长度为 1.00lgN

## 散列表

1.  拉链法
2.  线性探测法 开发地址散列表，通过数组中的空位解决碰撞

获取散列 key 值

1.  除留余数法(除于素数)
2.  浮点数(表示为二进制数，在使用除留余数法)

## 集合 (使用 es6 完成交，并， 差集)
